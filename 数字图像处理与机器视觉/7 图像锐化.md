图像锐化的目的是加强图像中景物的边缘和轮廓,也就是要使灰度反差增强.因为边缘和轮廓都位于灰度突变的地方。所以锐化算法的实现是基于微分作用.

一阶微分的计算公式:
$$f^{\prime}(x,y)=\frac{\partial f}{\partial x}+\frac{\partial f}{\partial y}$$
离散化之后的形式:
$$\Delta f(i,j)=[f(i+1,j)-f(i,j)]+[f(i,j+1)-f(i,j)]$$
## 一阶梯度算法
### 单方向锐化
#### 水平方向的锐化
公式:
$$H=\begin{bmatrix}1&2&1\\0&0&0\\-1&-2&-1\end{bmatrix}$$
#### 垂直方向的锐化
公式:
$$H=\begin{bmatrix}1&0&-1\\2&0&-2\\1&0&-1\end{bmatrix}$$
### 无方向锐化
#### 交叉微分算法(Roberts算法)
Roberts算法使用两个卷积核来计算水平和垂直方向的梯度.
![[数字图像处理与机器视觉/assets/Pasted image 20250417023205.png]]
两个卷积核:
第一个:
$$G_x=f(x+1,y)-f(x,y+1)$$
$$\begin{bmatrix}1&0\\0&-1\end{bmatrix}$$
第二个:
$$G_y=f(x,y+1)-f(x+1,y)$$
$$\begin{bmatrix}0&1\\-1&0\end{bmatrix}$$
两个卷积核的计算结果进行结合:
$$G=\sqrt{G_x^2+G_y^2}$$
#### Sobel锐化算法
Sobel也使用两个卷积核如下,但是其卷积核更大.
$$g(i,j)=\{d_x^2(i,j)+d_y^2(i,j)\}^2$$
$$d_x=\begin{bmatrix}-1&0&1\\-2&0&2\\-1&0&1\end{bmatrix}\quad d_y=\begin{bmatrix}-1&-2&-1\\0&0&0\\1&2&1\end{bmatrix}$$
#### Priwitt锐化算法
类似上面两个,卷积核细节不同.
$$g(i,j)=\{d_x^2(i,j)+d_y^2(i,j)\}^2$$
$$d_x=\begin{bmatrix}-1&0&1\\-1&0&1\\-1&0&1\end{bmatrix}\quad d_y=\begin{bmatrix}-1&-1&-1\\0&0&0\\1&1&1\end{bmatrix}$$
#### 三种算法对比
Sobel算法与Priwitt算法的思路相同，属于同一类型，因此处理效果基本相同.
Roberts算法的模板为2\*2，提取出的信息较弱.
## 二阶微分算法
为了更好捕捉图像的边缘,可以引入二阶导数来进行锐化.
### Laplascian算法
二阶微分算法使用的拉普拉斯算子:
$$\nabla^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}=4f(i,j)-f(i+1,j)-f(i-1,j)-f(i,j+1)-f(i,j-1)$$
可得写成模板系数形式的拉普拉斯算子:
$$H_1=\begin{bmatrix}0&-1&0\\-1&4&-1\\0&-1&0\end{bmatrix}$$

可以直接对上面的算子进行改变,获得拉普拉斯的变形算子:
$$H_2=\begin{bmatrix}-1&-1&-1\\-1&8&-1\\-1&-1&-1\end{bmatrix}\quad H_3=\begin{bmatrix}1&-2&1\\-2&4&-2\\1&-2&1\end{bmatrix}\quad H_4=\begin{bmatrix}0&-1&0\\-1&5&-1\\0&-1&0\end{bmatrix}$$
### Wallis算法
由于人眼的视觉特性中包含对数关系,因此锐化的时候加入对数处理的方法来改进.
$$\begin{aligned}&g(i,j)=\log[f(i,j)]-\frac{1}{4}s\\&s=[\log f(i-1,j)+\log f(i+1,j)+\log f(i,j-1)+\log f(i,j+1)\end{aligned}$$
![[数字图像处理与机器视觉/assets/Pasted image 20250417025511.png]]
